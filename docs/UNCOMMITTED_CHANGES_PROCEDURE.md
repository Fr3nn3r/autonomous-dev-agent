# Uncommitted Changes Detection & Resolution Procedure

When an ADA agent starts a session and detects uncommitted changes in the working directory, it should follow this procedure to analyze, categorize, and resolve them before beginning new work.

## Overview

Uncommitted changes can indicate:
- Interrupted sessions that didn't complete properly
- Schema migrations that weren't finalized
- Generated artifacts awaiting review
- Missing gitignore entries for transient files

Blindly committing or discarding changes risks losing work or polluting the repo. This procedure ensures thoughtful handling.

---

## Step 1: Inventory Changes

Run `git status --short` and categorize each item:

| Prefix | Meaning |
|--------|---------|
| `M` | Modified (staged) |
| ` M` | Modified (unstaged) |
| `A` | Added (staged) |
| `??` | Untracked |
| `D` | Deleted |

---

## Step 2: Categorize Each File

Assign each changed file to one of these categories:

### Category A: Session State Files (Transient)

Files that track agent runtime state. Should be gitignored.

**Pattern matches:**
- `.ada_*.json` (session state, alerts, discovery, history)
- `claude-progress-archive-*.txt` (rotated progress logs)
- `*_session_state.json`

**Action:** Add to `.gitignore`, do not commit.

### Category B: Tracking Files (Should Commit)

Files that track progress across sessions. Part of the project record.

**Pattern matches:**
- `claude-progress.txt` (append-only session log)
- `feature-list.json` (backlog with status updates)

**Action:** Review changes, commit if they represent completed work.

### Category C: Source Code Changes

Modified or new source files (`.py`, `.ts`, `.tsx`, `.js`, etc.)

**Analysis steps:**
1. Check `git diff` to understand what changed
2. Look for corresponding entries in `claude-progress.txt`
3. Check if related feature exists in `feature-list.json`
4. Verify tests pass if changes are significant

**Action:**
- If changes map to a completed feature: commit with appropriate message
- If changes are partial/broken: note in progress file, ask user
- If changes are experimental: stash or ask user

### Category D: Generated Artifacts

Reports, documentation, or outputs generated by tools.

**Examples:**
- `CODE_REVIEW.md` - code review reports
- `coverage/` - test coverage reports
- `*.generated.*` - auto-generated files

**Action:** Ask user whether to commit, gitignore, or delete.

### Category E: Environment/Config Files

**Examples:**
- `.env*` files (NEVER commit)
- `*.local` config files

**Action:** Ensure gitignored, warn if sensitive data present.

---

## Step 3: Check for Gitignore Gaps

Compare untracked files against `.gitignore`. If transient files are not ignored:

```bash
# Proposed additions to .gitignore
.ada_*.json
claude-progress-archive-*.txt
```

Update `.gitignore` before proceeding.

---

## Step 4: Map Changes to Requirements

For each Category B/C file, attempt to map to a known requirement:

1. Search `feature-list.json` for related feature IDs
2. Search `claude-progress.txt` for session entries mentioning the file
3. Check recent git log: `git log --oneline -10`

Document the mapping:
```
File: src/components/ChatInput.tsx
Related Feature: chat-input-validation (feature-list.json)
Last Session: s001_143022 (claude-progress.txt)
Status: Implementation complete, tests passing
```

---

## Step 5: Propose Resolution

Present findings to user with recommended actions:

```
## Uncommitted Changes Analysis

### Gitignore Updates Needed
- Add `.ada_alerts.json` to .gitignore
- Add `claude-progress-archive-*.txt` to .gitignore

### Ready to Commit
- `claude-progress.txt` - Session log updates from s001_143022
- `feature-list.json` - Status update for chat-input-validation

### Requires User Decision
- `CODE_REVIEW.md` - Generated report (commit/ignore/delete?)

### Source Changes Requiring Review
- `src/components/ChatInput.tsx` - Partial implementation, tests failing
  Recommendation: Complete implementation or stash for later
```

---

## Step 6: Execute Resolution

With user approval:

1. **Update .gitignore** for transient files
2. **Commit tracking files** with descriptive message:
   ```
   chore: update progress tracking after session s001_143022
   ```
3. **Handle source changes** per user direction
4. **Clean up** any files user chose to delete

---

## Implementation Checklist

For ADA harness implementation, the agent should:

- [ ] Run git status at session start
- [ ] If uncommitted changes exist, pause before feature work
- [ ] Execute categorization algorithm
- [ ] Present analysis to user via progress file or console
- [ ] Wait for user approval before committing/discarding
- [ ] Log resolution in progress file

---

## Example Session Flow

```
[Agent Start]
> Detected 6 uncommitted changes

[Categorization]
> Category A (gitignore): 3 files
> Category B (tracking): 2 files
> Category D (generated): 1 file

[Analysis]
> Tracking changes map to completed feature 'api-error-handling'
> Generated CODE_REVIEW.md has no associated requirement

[Proposal]
> Recommend: Update gitignore, commit tracking files
> User decision needed for: CODE_REVIEW.md

[User Response]
> "Commit the review too"

[Resolution]
> Updated .gitignore (+3 patterns)
> Committed: claude-progress.txt, feature-list.json, CODE_REVIEW.md
> Message: "chore: finalize api-error-handling, add code review"

[Proceed]
> Working directory clean, starting feature work...
```

---

## Edge Cases

### Large Number of Uncommitted Files
If >20 uncommitted files, likely indicates a major interrupted session. Recommend:
1. Create a WIP branch
2. Commit everything with "WIP: interrupted session recovery"
3. Ask user to review before merging

### Merge Conflicts in Tracking Files
If `feature-list.json` or `claude-progress.txt` have conflicts:
1. Prefer the version with more recent timestamps
2. Manually merge if entries are complementary
3. Never lose session history

### Sensitive Data Detected
If any file contains patterns matching API keys, passwords, or secrets:
1. STOP immediately
2. Warn user
3. Do not commit under any circumstances
4. Recommend `git reset` and manual cleanup
